# 운영체제 스터디 요약 - 6주차

## 1. 가상 메모리(Virtual Memory)

### 정의
- 물리 메모리(RAM)보다 더 큰 메모리 공간을 사용하는 것처럼 보이게 하는 기술
- 실제 메모리 크기 이상의 프로세스 실행 가능

### 필요한 이유

**1. 메모리 효율성**
- 프로세스 전체를 메모리에 올릴 필요 없음
- 필요한 부분만 메모리에 로드

**2. 추상화(Abstraction)**
- 프로세스는 가상 주소만 인식
- 물리 주소는 OS가 관리 (개발자 모르게)
- 보안성 향상

**3. 독립적 주소 공간**
- 각 프로세스마다 0번지부터 시작하는 독립적인 가상 주소 공간
- 프로세스 간 메모리 격리 (보안)

### 가상 메모리 구현

**저장 위치:**
- RAM에 부족한 부분은 디스크(SSD/HDD)에 저장
- 필요할 때 디스크에서 RAM으로 로드

**비용:**
- 디스크 접근이 RAM 접근보다 훨씬 느림
- 따라서 불필요한 스왑(Swap) 최소화 필요

---

## 2. 페이징(Paging)

### 정의
- 물리 메모리와 가상 메모리를 **같은 크기의 블록(페이지)**으로 나누는 기법
- 불연속 메모리 할당 (외부 단편화 해결)

### 구성 요소

**페이지 (Page):**
- 가상 메모리의 블록 (일반적으로 4KB)

**프레임 (Frame):**
- 물리 메모리의 블록 (페이지와 같은 크기)

**페이지 테이블 (Page Table):**
- 가상 주소 → 물리 주소 변환 정보 저장
- 각 프로세스마다 독립적인 페이지 테이블 보유

### 주소 변환 과정

```
가상 주소 = 페이지 번호 | 오프셋

예: 32비트 가상 주소에서 4KB 페이지 크기
- 페이지 번호: 상위 20비트
- 오프셋: 하위 12비트

페이지 테이블 참조:
가상 페이지 번호 → 물리 프레임 번호 변환

최종 물리 주소 = 물리 프레임 번호 | 오프셋
```

### 페이지 번호와 오프셋 사용 이유

**1. 페이지 테이블 최소화**
- 전체 프로세스를 하나의 인덱스로 관리 가능
- 페이지 테이블의 크기를 줄일 수 있음

**2. 성능**
- 같은 크기의 블록으로 관리하면 효율적
- 빠른 검색과 매핑 가능

**3. 유연성**
- 페이지 단위로 메모리 관리
- 페이지 교체 알고리즘 적용 용이

---

## 3. 페이지 폴트(Page Fault)

### 정의
- 프로세스가 접근하려는 페이지가 물리 메모리(RAM)에 없는 상황
- OS가 페이지를 디스크에서 RAM으로 로드

### 발생 상황

**1. 첫 접근 (Cold Start)**
- 프로세스 시작 시 페이지가 메모리에 없음

**2. 메모리 부족**
- 다른 페이지가 메모리를 차지중
- 새로운 페이지를 위해 기존 페이지 교체 필요

### 처리 과정

1. CPU가 페이지 접근 시도
2. MMU (Memory Management Unit)가 페이지 폴트 감지
3. OS가 디스크에서 페이지 로드
4. 페이지 테이블 업데이트
5. 프로세스 재개

---

## 4. 페이지 교체 알고리즘(Page Replacement Algorithm)

### FIFO (First In First Out)
- **개념**: 가장 먼저 들어온 페이지를 먼저 제거
- **장점**: 구현이 간단
- **단점**: 자주 사용하는 페이지도 제거될 수 있음

### LRU (Least Recently Used)
- **개념**: 가장 오래전에 사용한 페이지를 제거
- **사용 시점**: 시간 순서로 추적
- **장점**: 자주 사용하는 페이지 보호
- **실무**: 대부분의 OS에서 사용

### LFU (Least Frequently Used)
- **개념**: 가장 적게 사용된 페이지 제거
- **사용 횟수**: 횟수 기반 추적

### 비교

| 알고리즘 | 기준 | 구현 복잡도 | 성능 |
|---------|------|-----------|------|
| FIFO | 들어온 순서 | 낮음 | 낮음 |
| LRU | 최근 사용 시점 | 중간 | 높음 |
| LFU | 사용 횟수 | 높음 | 중간 |

---

## 5. 스래싱(Thrashing)

### 정의
- 페이지 폴트가 너무 자주 발생하여 **페이징 하는 시간이 실제 작업 시간보다 많아지는 현상**
- CPU 대기 시간 증가, 성능 급격히 저하

### 발생 이유

**메모리 부족:**
- 메모리에 올릴 수 있는 페이지가 적음
- 계속 페이지 교체 필요
- 방금 제거한 페이지를 다시 필요로 함

**악순환:**
```
메모리 부족 
→ 페이지 폴트 증가
→ 더 많은 프로세스를 메모리에 올림
→ 메모리 더 부족
→ 페이지 폴트 더 증가
→ CPU 유휴(Idle) 상태
```

### 해결 방법

**1. 메모리 증가**
- 가장 직접적인 해결책
- 물리 메모리 추가

**2. 프로세스 감소**
- 동시 실행 프로세스 수 줄임
- 각 프로세스에 충분한 메모리 할당

**3. Working Set 관리**
- 프로세스가 실제 필요한 페이지 세트만 메모리에 유지
- 예측 기반 페이지 프리페칭

---

## 6. 내부 단편화(Internal Fragmentation)

### 정의
- **할당된 메모리 공간보다 실제 사용량이 적어서 낭비되는 현상**
- 페이징 기반 메모리 관리에서 발생

### 예시

```
프로세스가 10KB 필요
하지만 페이지 크기가 4KB이므로 3개 페이지(12KB) 할당
→ 2KB가 낭비됨 (내부 단편화)
```

### 특징

- **고정 페이지 분할에서 발생**
- 페이지 하나의 마지막 부분에 낭비 공간 생김
- 프로세스마다 평균적으로 발생 (크기의 절반 정도)

---

## 7. 외부 단편화(External Fragmentation)

### 정의
- **메모리의 이곳저곳에 비어있는 공간이 있지만, 연속된 충분한 공간이 없어서 할당 실패하는 현상**
- 불연속 메모리 할당에서 발생 가능

### 예시

```
메모리: [프로세스A] [2KB] [프로세스B] [3KB] [프로세스C] [1KB]
        
총 비어있는 공간: 6KB
하지만 연속된 4KB 공간이 필요한 프로세스는 할당 불가
```

### 해결 방법

**1. 페이징 (완전 해결)**
- 불연속 메모리 할당으로 외부 단편화 없음
- 대신 내부 단편화 발생

**2. 메모리 압축(Compaction)**
- 사용 중인 메모리를 한쪽으로 몰아주기
- 비용이 높음 (모든 프로세스 상태 변경)

**3. 세그먼테이션**
- 가변 크기로 메모리 분할
- 외부 단편화는 여전히 발생 가능

---

## 8. 연속 메모리 할당(Contiguous Allocation) vs 불연속 할당(Non-Contiguous Allocation)

### 연속 메모리 할당

**정의:** 프로세스에 연속된 메모리 공간 할당

**분할 방식:**

1. **고정 분할 (Fixed Partition)**
   - 메모리를 미리 정해진 크기로 분할
   - 문제: 내부 단편화 발생

2. **가변 분할 (Variable Partition)**
   - 프로세스 크기에 맞게 동적으로 분할
   - 문제: 외부 단편화 발생

### 불연속 메모리 할당

**정의:** 프로세스 메모리가 여러 곳에 분산 가능

**방식:**

1. **페이징**
   - 고정 크기 페이지로 분할
   - 내부 단편화만 발생 (적음)
   - 외부 단편화 없음

2. **세그먼테이션**
   - 논리적 단위(코드, 데이터 등)로 분할
   - 외부 단편화 가능

### 비교

| 항목 | 연속 할당 | 불연속 할당 |
|------|---------|----------|
| 구현 | 간단 | 복잡 |
| 외부 단편화 | 있음 (고정) 또는 있음 (가변) | 없음 (페이징) |
| 내부 단편화 | 없음 또는 거의 없음 | 있음 (페이징) |
| 메모리 활용 | 낮음 | 높음 |
| 성능 | 높음 | 중간 |

---

## 9. 메모리 관리 장치(MMU - Memory Management Unit)

### 정의
- 가상 주소를 물리 주소로 변환하는 하드웨어 장치

### 역할

**1. 주소 변환**
- 가상 주소 → 물리 주소 변환
- 페이지 테이블 참조

**2. 메모리 보호**
- 프로세스가 자신의 메모리 범위만 접근
- 다른 프로세스 메모리 접근 방지

**3. 캐싱**
- TLB (Translation Lookaside Buffer)
- 자주 사용하는 변환 정보 캐싱
- 성능 향상

---

## 📝 핵심 정리

| 개념 | 핵심 |
|------|------|
| 가상 메모리 | 추상화로 보안성과 효율성 향상 |
| 페이징 | 같은 크기 블록으로 외부 단편화 해결 |
| 페이지 폴트 | RAM에 없는 페이지 접근 |
| 페이지 교체 | LRU가 가장 실용적 |
| 스래싱 | 페이징 시간 > 작업 시간 |
| 내부 단편화 | 페이징에서 발생 (적음) |
| 외부 단편화 | 연속 할당에서 발생, 페이징으로 해결 |
| MMU | 가상 → 물리 주소 변환 |

---

## 면접 팁

**가상 메모리:**
- 자동차 전화번호 비유 활용
- 프로세스 0번지부터 시작하는 이유는 추상화 때문

**페이징:**
- 페이지 번호/오프셋 분리가 핵심
- 페이지 테이블 크기 최소화 설명

**스래싱:**
- CPU 유휴 상태가 발생한다는 점 강조
- 메모리 증가가 가장 직접적 해결책

**단편화:**
- 내부 vs 외부 단편화의 발생 시점 명확히
- 페이징으로 완벽하게 외부 단편화 해결됨을 강조
