# 데이터베이스 스터디 요약 - 7주차

## 1. 커넥션 풀(Connection Pool)

### 정의
- 데이터베이스와의 통신을 위해 사전에 만들어진 커넥션들의 집합
- 필요할 때마다 풀에서 커넥션을 받아 사용하고 반환

### 필요한 이유

**TCP/IP 통신의 비용:**
- 데이터베이스 요청마다 TCP/IP 연결 맺기 필요
- 3-way handshake로 인한 리소스 소비 높음
- 매번 연결-해제를 반복하는 것은 비효율적

**HTTP 버전 비유:**
- HTTP 1.0: 요청마다 커넥션 맺음 (매번 3-way handshake)
- HTTP 1.1: Keep-Alive로 개선 (연결 재사용)
- 커넥션 풀: DB에서의 동일한 개념

### 커넥션 풀 크기

**너무 크면 문제:**
- DB에서 max_connection 제한 있음
- 쓸데없이 큰 풀 → DB가 처리할 수 있는 연결 초과
- DB 자체가 나중에 요청을 처리 못함

**최적화:**
- DB의 max_connection을 고려하여 풀 크기 결정
- 모니터링을 통해 적절한 크기 유지

---

## 2. 정규화(Normalization)

### 정의
- 데이터베이스 설계에서 중복을 제거하고 이상 상태(Anomaly)를 방지하는 과정
- 데이터 무결성 보장

### 정규화를 하는 이유

**1. 데이터 중복 제거**
- 같은 데이터가 여러 곳에 저장되는 것 방지

**2. 이상 상태(Anomaly) 제거**
- **삽입 이상**: 불필요한 데이터도 함께 삽입
- **수정 이상**: 한 데이터를 수정할 때 여러 곳을 수정해야 함
- **삭제 이상**: 필요한 데이터까지 함께 삭제됨

### 정규화의 단점

**1. 조회 성능 저하**
- 정규화된 테이블들을 조인(JOIN)해서 데이터 조회
- JOIN 과정에서 추가 IO 발생

**2. 쓰기 성능 저하**
- 하나의 논리적 작업이 여러 테이블에 걸쳐 수행
- 쓰기 작업이 더 오래 걸릴 수 있음

### 정규화가 항상 좋은 것은 아님

**비정규화(Denormalization) 사용:**
- 성능이 중요한 경우 의도적으로 데이터 중복 허용
- 읽기 성능 향상을 위해 역정규화 적용
- 예: JSON 컬럼에 복합 데이터 저장, 캐싱

**설계 시점:**
- 보통 정규화를 고려해서 설계
- 실제 운영 중에 정규화를 적용하는 경우는 드뭄
- 운영 중 최적화는 주로 인덱스 추가, 캐싱 등

---

## 3. 트랜잭션(Transaction)

### 정의
- 데이터베이스의 **최소 논리 단위**
- 더 이상 분해할 수 없는 작업의 최소 단위

### ACID 특성

**A - 원자성 (Atomicity)**
- 트랜잭션 내 모든 작업이 완료되거나 전혀 실행되지 않음
- All or Nothing

**C - 일관성 (Consistency)**
- 트랜잭션 전후 데이터 상태가 일관성 있게 유지
- 데이터 무결성 보장

**I - 격리성 (Isolation)**
- 동시에 실행되는 트랜잭션들이 서로 간섭하지 않음
- 각 트랜잭션은 독립적으로 실행

**D - 지속성 (Durability)**
- 커밋된 데이터는 영구적으로 저장
- 시스템 장애 후에도 데이터 보존

---

## 4. 트랜잭션 격리 수준(Isolation Level)

### 4가지 수준 (낮은 순서대로)

**1. Read Uncommitted (미커밋 읽기)**
- 커밋되지 않은 데이터도 읽을 수 있음
- **Dirty Read 발생**: 롤백된 데이터를 읽을 수 있음
- 예: 상품 재고 문제 (구매 후 롤백 시 재고 불일치)

**2. Read Committed**
- 커밋된 데이터만 읽음
- **Phantom Read, Non-repeatable Read 발생 가능**
- 대부분의 DB 기본값

**3. Repeatable Read**
- 같은 데이터를 여러 번 읽어도 동일한 결과 보장
- **Phantom Read 발생 가능** (새로운 로우 추가)
- MySQL: MVCC로 대부분의 Phantom Read 해결

**4. Serializable (직렬화)**
- 완전한 격리 (동시성 거의 없음)
- 가장 안전하지만 성능 매우 낮음

### DB별 기본 격리 수준

| DB | 기본 격리 수준 |
|-----|-------------|
| MySQL (InnoDB) | Repeatable Read |
| Oracle | Read Committed |
| PostgreSQL | Read Committed |

### MySQL의 특수성

**MySQL MVCC (Multi-Version Concurrency Control):**
- Repeatable Read 수준에서도 Phantom Read 대부분 해결
- 트랜잭션 시작 시점의 스냅샷 기반으로 동작
- 구현이 잘 되어있음

---

## 5. 이상 상태(Anomaly) 상세

### Dirty Read
- **정의**: 커밋되지 않은 데이터를 읽는 현상
- **예시**: 
  - 사용자 A: 상품 개수를 5에서 3으로 수정 (미커밋)
  - 사용자 B: 상품 개수 3 조회
  - 사용자 A: 수정 취소 (롤백)
  - 결과: 사용자 B가 존재하지 않는 데이터를 읽음

### Non-Repeatable Read
- **정의**: 같은 데이터를 두 번 읽을 때 다른 값이 나오는 현상
- **예시**: 트랜잭션 중간에 다른 사용자가 데이터 수정

### Phantom Read
- **정의**: 같은 범위의 데이터를 두 번 조회할 때 새로운 로우가 나타나는 현상
- **예시**: 트랜잭션 중간에 새로운 상품이 추가됨

---

## 6. Spring 트랜잭션 전파(Propagation)

### 주요 전파 속성

**1. REQUIRED** (기본값)
- 현재 트랜잭션이 있으면 이용
- 없으면 새로 생성

**2. REQUIRES_NEW**
- 항상 새로운 트랜잭션 생성
- 기존 트랜잭션과 독립적

**3. NEVER**
- 트랜잭션 없이 실행
- 트랜잭션이 있으면 예외 발생

**4. SUPPORT**
- 트랜잭션이 있으면 이용, 없으면 비트랜잭션으로 실행

**5. NOT_SUPPORTED**
- 비트랜잭션으로 실행
- 기존 트랜잭션은 일시 중단

**6. MANDATORY**
- 반드시 트랜잭션 필요
- 없으면 예외 발생

**7. NESTED**
- 중첩 트랜잭션 (세이브포인트 사용)

### 실무에서 주로 사용

**REQUIRED** (가장 일반적)
- 대부분의 비즈니스 로직

**REQUIRES_NEW**
- 독립적으로 처리해야 하는 로직
- 예: 로그 저장, 알림 발송 등

---

## 📝 핵심 정리

| 개념 | 핵심 |
|------|------|
| 커넥션 풀 | TCP 3-way handshake 비용 절감 |
| 정규화 | 중복 제거, 이상 상태 제거 |
| 비정규화 | 성능 향상을 위한 의도적 중복 |
| 트랜잭션 | DB의 최소 논리 단위 (ACID) |
| 격리 수준 | Read Uncommitted < Read Committed < Repeatable Read < Serializable |
| MVCC | MySQL의 동시성 제어 메커니즘 |
| 트랜잭션 전파 | REQUIRED와 REQUIRES_NEW 주로 사용 |

---

## 면접 팁

**커넥션 풀:**
- TCP 연결 비용이 높다는 점이 핵심
- HTTP Keep-Alive와의 유사성 설명 가능

**정규화:**
- 항상 좋은 것이 아니라는 점 강조
- 성능과 비정규화의 트레이드오프 이해

**트랜잭션 격리 수준:**
- 실제 경험한 이상 상태 예시 들기
- MySQL MVCC의 특수성 언급

**트랜잭션 전파:**
- 실무에서 REQUIRED와 REQUIRES_NEW의 차이 이해
- 독립적으로 처리해야 하는 로직의 예시 제시
