# 운영체제 스터디 요약 - 4주차

## 1. 프로세스(Process)

### 정의
- **실행 중인 프로그램**
- 메모리에 적재된 프로그램 + PCB(Process Control Block) 할당

### PCB (Process Control Block)

**포함 정보:**
- PID (Process ID)
- 레지스터 값
- 프로그램 카운터 (PC)
- 스케줄링 정보
- 상태 정보

**역할:** 프로세스의 모든 정보를 관리

### 프로세스 종료 후
- 메모리에서 완전히 나간 후, 그 PID를 새로운 프로세스가 사용 가능
- 메모리가 남아 있으면 안 됨

---

## 2. 스레드(Thread)

### 정의
- **프로세스 내에서 실행되는 실행 흐름**
- 프로세스 내 여러 개 존재 가능

### TCB (Thread Control Block)
- TID (Thread ID)
- 프로그램 카운터 (PC)
- 레지스터 값
- 스택 정보
- 스케줄링 정보

---

## 3. 프로세스 vs 스레드

### 메모리 구조 비교

| 항목 | 프로세스 | 스레드 |
|------|---------|--------|
| 코드 영역 | 독립적 | 공유 |
| 데이터 영역 | 독립적 | 공유 |
| 힙 영역 | 독립적 | 공유 |
| 스택 영역 | 독립적 | 독립적 |

### 특징 비교

| 항목 | 프로세스 | 스레드 |
|------|---------|--------|
| 생성 비용 | 높음 | 낮음 |
| 컨텍스트 스위칭 | 느림 | 빠름 |
| 통신 | IPC 필요 | 공유 메모리 직접 접근 |
| 메모리 사용 | 많음 | 적음 |

### 컨텍스트 스위칭 비용

**프로세스:**
- 코드, 데이터, 힙, 스택 모두 전환
- 메모리 매핑 변경
- 비용 높음

**스레드:**
- 스택만 전환
- 나머지는 공유하므로 전환 불필요
- 비용 낮음

---

## 4. 프로세스 메모리 구조

### 4가지 메모리 영역

**1. 코드 영역 (Code)**
- 프로그램의 실행 코드 저장
- 읽기 전용
- 크기: 고정 (정적)

**2. 데이터 영역 (Data)**
- 전역 변수, 정적 변수
- 초기화된 데이터
- 크기: 고정 (정적)

**3. 힙 영역 (Heap)**
- 동적 할당 메모리
- malloc, new로 할당
- 증가 방향: 아래에서 위로
- 크기: 가변 (동적)

**4. 스택 영역 (Stack)**
- 함수 호출, 지역 변수
- 매개변수, 반환 주소
- 증가 방향: 위에서 아래로
- 크기: 가변 (동적)

### 메모리 증가 방향

```
메모리 주소 (위로 갈수록 높음)

┌─────────────────────┐
│   스택 (Stack)      │ ← 위에서 아래로 증가
│                     │
├─────────────────────┤
│   (비어있는 공간)   │
├─────────────────────┤
│   힙 (Heap)         │ ← 아래에서 위로 증가
├─────────────────────┤
│   데이터 (Data)     │
├─────────────────────┤
│   코드 (Code)       │ ← 읽기 전용
└─────────────────────┘

메모리 주소 (아래로 갈수록 낮음)
```

### 스택 오버플로우
- 스택 영역 초과
- 원인: 무한 재귀 호출, 너무 큰 지역 변수
- 결과: 힙 영역과 충돌 → 프로그램 크래시

---

## 5. JVM 메모리 구조

### 5가지 메모리 영역

**1. 메서드 영역 (Method Area)**
- 클래스 정보, 메서드 정보, 정적 변수
- 스레드 공유
- Java 8 이전: Permanent Generation
- Java 8 이후: Metaspace (Heap 외부)

**2. 힙 영역 (Heap)**
- 객체, 인스턴스 변수 저장
- 스레드 공유
- GC (Garbage Collection) 대상

**3. 스택 영역 (Stack)**
- 메서드 호출, 지역 변수, 매개변수
- 스레드 독립적
- 메서드 반환 시 자동 해제

**4. PC 레지스터 (Program Counter Register)**
- 현재 실행 중인 JVM 명령어 주소
- 스레드 독립적

**5. 네이티브 메서드 스택 (Native Method Stack)**
- C/C++ 같은 네이티브 코드 실행
- JNI (Java Native Interface) 사용

### 스레드 관점

**공유 영역:**
- 메서드 영역
- 힙 영역

**독립적 영역:**
- 스택
- PC 레지스터
- 네이티브 메서드 스택

### Java 8 변화: Permanent Generation → Metaspace

**이유:**
- Perm Gen의 OutOfMemoryError 문제
- 고정 크기 메모리 한계
- Metaspace: 동적 크기 조정 가능
- OS 네이티브 메모리 사용

---

## 6. 멀티스레드의 문제점

### 스레드가 많으면 문제

**문제:**
1. 컨텍스트 스위칭 빈번
2. CPU 자원이 스레드 관리에 소비
3. 동기화 관리 복잡성 증가 → 버그 발생 확률 ↑

### Race Condition (경합)

**정의:**
- 여러 스레드가 공유 메모리에 동시 접근
- 실행 순서에 따라 결과가 달라지는 현상

**예시:**
```
스레드 1: x = 5; x++;
스레드 2: x = 5; x++;

결과: x = 6 (또는 x = 7, 순서에 따라 다름)
```

---

## 7. 스레드 안전성 (Thread Safety)

### 3가지 성질

**1. 원자성 (Atomicity)**
- 작업이 중단되지 않고 완료
- 더 이상 쪼갤 수 없는 단위
- 구현: Atomic 클래스

**2. 순서성 (Ordering)**
- 명령어 실행 순서 보장
- 메모리 배치 최적화에 의한 순서 변경 방지
- 구현: Synchronized, Lock

**3. 가시성 (Visibility)**
- 한 스레드의 변경사항이 다른 스레드에 보임
- 각 스레드가 본인 캐시를 사용하면 변경사항이 보이지 않을 수 있음
- 구현: volatile, Synchronized

---

## 8. 동기화 기법

### 뮤텍스 (Mutex) vs 세마포어 (Semaphore)

| 항목 | 뮤텍스 | 세마포어 |
|------|--------|----------|
| 정의 | 상호 배제 | 신호 메커니즘 |
| 개수 | 1개 (0 또는 1) | N개 가능 |
| 접근 가능 스레드 | 1개만 | N개 |
| 용도 | 임계 영역 보호 | 자원 개수 제어 |

**관계:**
```
뮤텍스 ⊂ 세마포어
(이진 세마포어 = 뮤텍스)
```

### Java 동기화 기법 비교

| 기법 | 원자성 | 순서성 | 가시성 | 성능 |
|------|--------|--------|--------|------|
| synchronized | ✓ | ✓ | ✓ | 낮음 |
| volatile | | | ✓ | 높음 |
| Atomic | ✓ | | | 중간 |
| Lock | ✓ | ✓ | ✓ | 낮음 |

### 각 기법의 용도

**Synchronized:**
- 가장 강력한 동기화
- Lock 대기 시간 있음

**Volatile:**
- 가시성만 필요한 경우
- 플래그 변수, 상태 확인

**Atomic:**
- CAS 알고리즘 사용
- 카운터, ID 생성

---

## 9. 프로세스 간 통신 (IPC)

### IPC 필요성
- 프로세스는 독립적인 메모리 공간
- 직접 메모리 공유 불가능
- 통신 메커니즘 필요

### IPC 방법들

**1. 파이프 (Pipe)**
- 프로세스 간 단방향 통신
- 예: Linux 명령어 `|` 연산자
- `ps | grep java`

**2. 메시지 큐 (Message Queue)**
- 큐에 메시지를 넣고 빼는 방식
- OS 레벨 IPC
- (RabbitMQ, Redis와는 다름)

**3. 소켓 (Socket)**
- 네트워크 기반 통신
- TCP/UDP

**4. 공유 메모리 (Shared Memory)**
- 두 프로세스가 같은 메모리 접근
- 가장 빠른 IPC 방식

**5. 세마포어 (Semaphore)**
- 동기화 메커니즘
- 자원 접근 제어

---

## 10. 멀티프로세스 vs 멀티스레드

### Chrome 브라우저 예시

**각 탭 = 독립적인 프로세스**
- 탭 간 메모리 공유 없음
- 한 탭이 크래시해도 다른 탭은 동작
- 각 탭 내에서 여러 스레드 사용

**왜 프로세스로 분리?**
- 안정성: 한 탭이 다른 탭에 영향 없음
- 보안: 탭 간 격리
- 성능: 멀티코어 활용

---

## 11. CPU 코어와 스레드

### 물리 코어 vs 논리 스레드

**물리 코어:**
- 실제 하드웨어 (고정)

**논리 스레드:**
- 코어가 동시에 처리할 수 있는 작업 단위
- 물리 코어보다 많을 수 있음

### 예시

**Intel Core i9:**
- 8 cores / 16 threads
- 하이퍼스레딩으로 2배

**ARM (iPhone):**
- A15 Bionic: 6코어 (2개 고성능 + 4개 효율성)

---

## 12. 싱글 스레드 모델

### Redis와 Node.js가 싱글 스레드인데 빠른 이유

**장점:**
1. **컨텍스트 스위칭 없음**
   - CPU 자원 낭비 없음
   - 캐시 효율성 증가

2. **동기화 문제 없음**
   - 복잡한 동기화 불필요
   - 버그 감소

3. **메모리 효율**
   - 스레드 관리 비용 없음

### Redis의 경우
- 인메모리 데이터베이스
- 네트워크 I/O가 병목 (CPU 아님)
- Non-blocking I/O (비동기)로 처리

### Node.js의 경우
- JavaScript 싱글 스레드
- 이벤트 루프 + 비동기 콜백으로 동시성 구현
- Non-blocking I/O

### 한계
- CPU 집약적 작업에는 부적합
- I/O 중심 작업에만 최적

---

## 13. 메모리 부족 시 처리

### 가상 메모리

**페이징 (Paging):**
- 같은 크기의 페이지로 분할
- 페이지 테이블로 매핑

**세그먼테이션 (Segmentation):**
- 다양한 크기로 분할
- 논리적 단위 (코드, 데이터 등)

### 성능 문제
- 메모리 부족 시 디스크 접근
- 속도 현저히 저하

---

## 📝 핵심 정리

| 개념 | 핵심 |
|------|------|
| 프로세스 | 독립적 메모리 + PCB |
| 스레드 | 공유 메모리 + 독립적 스택 |
| 컨텍스트 스위칭 | 스레드가 프로세스보다 빠름 |
| 메모리 영역 | 코드, 데이터, 힙, 스택 |
| 원자성 | 중단되지 않는 작업 |
| Race Condition | 동시 접근으로 인한 문제 |
| IPC | 프로세스 간 통신 메커니즘 |
| 싱글 스레드 | I/O 중심 작업에 최적 |
