# CS 스터디 요약 - 1228 녹음

## 주제: RDBMS, NoSQL, 데이터 확장 전략 (Week 9)

### 1. ACID 특성

#### 정의
RDBMS의 필수 특성 4가지 (Atomicity, Consistency, Isolation, Durability)

#### 각 속성 상세 설명

##### A - Atomicity (원자성)
- **개념**: 더 이상 쪼갤 수 없는 최소 단위
- **DB 적용**: 트랜잭션은 전체 성공하거나 전체 실패해야 함
- **예시**: 송금 거래는 "차감" + "입금"이 모두 성공하거나 모두 실패
- **구현**: 커밋(Commit) 또는 롤백(Rollback)
- **목표**: 데이터 일관성 유지

##### C - Consistency (일관성)
- **개념**: 데이터의 정확성과 무결성 보장
- **원자성과의 관계**: 원자성을 통해 일관성이 달성됨

##### I - Isolation (격리성)
- **개념**: 동시에 실행되는 트랜잭션들이 서로 독립적으로 동작
- **목표**: 동시성 제어로 데이터 정합성 유지

##### D - Durability (지속성)
- **개념**: 커밋된 데이터는 영구적으로 저장
- **보장**: 시스템 장애 후에도 데이터 유지

---

### 2. RDBMS vs NoSQL

#### RDBMS (Relational Database Management System)

**특징**
- 고정된 스키마와 테이블 구조
- 정형 데이터(Structured Data) 저장
- 강력한 ACID 특성 준수
- 데이터 정확성 우선

**사용 사례**
- 결제 및 정산 시스템
- 계약 관리
- 정적인 데이터 보관
- 데이터 무결성이 중요한 업무

**저장 방식**
- B-Tree 기반 (기본 자료구조)

#### NoSQL (Not Only SQL)

**특징**
- 가변적 스키마 (Schema-less)
- 키-밸류 방식 저장
- 대용량 데이터 처리 용이
- 읽기/쓰기 속도 우선

**사용 사례**
- 실시간 이벤트 처리
- 로그 데이터
- 센서 데이터
- 데이터 구조가 자주 변하는 경우
- 캐싱

**특징 정리**
- 트랜잭션 미지원 (최근 일부 지원)
- MongoDB 등 최신 NoSQL은 트랜잭션 제공

#### 주요 차이점 비교

| 항목 | RDBMS | NoSQL |
|------|-------|-------|
| 스키마 | 고정 | 가변 |
| 데이터 구조 | 정형 | 비정형 |
| ACID | 강력함 | 약함 |
| 트랜잭션 | 지원 | 미지원 (최근 일부 지원) |
| 확장성 | 수직 확장 | 수평 확장 |
| 사용 목적 | 데이터 정확성 | 대용량 처리 |

---

### 3. 대용량 데이터 처리 전략

#### 문제 정의
대용량 데이터 발생 시 발생하는 이슈:
- 조회 성능 저하
- 쓰기 성능 저하
- 단일 DB 관리 시 안정성 문제

#### 해결 방안 4가지

---

### 4. Replication (레플리케이션)

#### 개념
- **정의**: 데이터베이스 복제
- **목표**: 대용량 데이터 처리를 위한 분산 기술
- **구조**: Master-Slave 아키텍처

#### 동작 원리

##### 읽기 성능 향상
- **Master DB**: 쓰기 담당
- **Slave DB(Replica)**: 읽기 담당
- 마스터 데이터를 슬레이브에 복제하여 읽기 부하 분산

**구조도**
```
Master DB (Write)
    ↓ 복제
Slave DB (Read) ← 읽기 요청
Slave DB (Read) ← 읽기 요청
```

#### 실제 사용
- 읽기 요청이 많은 경우 효과적
- 여러 Slave로 읽기 부하 분산

---

### 5. Sharding (샤딩)

#### 개념
- **정의**: 데이터를 분할하여 여러 DB에 저장하는 기술
- **목표**: 쓰기 성능 향상 및 병목 현상 해결
- **방식**: 수평 확장 (Scale-Out)

#### Sharding Key의 역할
- 단순 분할 기술이 아님
- **Sharding Key**: 어느 DB에 데이터를 저장할지 결정하는 라우팅 키
- 역할: 데이터를 특정 DB로 라우팅

**예시**
```
사용자 ID를 샤딩키로 사용:
- ID 1~1000 → DB1
- ID 1001~2000 → DB2
- ID 2001~3000 → DB3

새 요청: 사용자 ID 1500
→ Sharding Key를 통해 DB2로 라우팅
```

#### 쓰기 성능 향상 이유
- 분할된 DB에 병렬로 쓰기 가능
- 병목 현상 완화

#### NoSQL과 Sharding
- MongoDB 등 NoSQL은 자체적으로 Sharding 지원
- RDBMS는 애플리케이션 레벨에서 구현

#### 샤딩의 한계
- 확장 전략 중 마지막 수단
- **균등 분배 필수**: 킷값이 골고루 분배되지 않으면 효과 감소
- 복잡도 증가로 인한 관리 비용

#### 균등 분배 방법
- **Hash 기반**: PK를 해싱 처리하여 균등 분배
- **ULID**: 시간 기반의 균등 분배 방식
- 각 샤딩 키마다 고유한 DB 할당 가능

#### 실무 경험
- 샤딩을 직접 구현한 경험 없음
- Active-Standby 방식만 사용
- Partitioning은 사용하지만 Sharding은 미사용

---

### 6. Partitioning (파티셔닝)

#### 개념
- **정의**: 대용량 테이블을 물리적으로 분할하는 기술
- **목표**: 읽기 성능 향상
- **특징**: 같은 DB 내에서 논리적 분할

#### 파티셔닝의 필요성
대용량 데이터 처리 시:
1. 조회 성능 저하
2. 쓰기 성능 저하
3. 안정성 문제
→ 파티셔닝으로 해결

#### 파티셔닝 종류

##### 1. 수평 파티셔닝 (Horizontal Partitioning)
- **분할 기준**: 행(Row)
- **예시**: 시간대별로 분할
  ```
  2024년 데이터 → Partition 1
  2025년 데이터 → Partition 2
  ```

##### 2. 수직 파티셔닝 (Vertical Partitioning)
- **분할 기준**: 컬럼(Column)
- **예시**: 개인정보와 거래정보 분리
  ```
  개인정보 (이름, 주소) → Partition 1
  거래정보 (거래액, 날짜) → Partition 2
  ```
- **장점**: 데이터 특성에 따라 분리 저장
- **실제 사용**: 자주 사용하는 컬럼과 미사용 컬럼 분리

#### 파티셔닝 vs Replication vs Sharding 비교

| 기술 | 목표 | 분할 대상 | 특징 |
|------|------|---------|------|
| Replication | 읽기 성능 ↑ | 테이블 복제 | Master-Slave |
| Sharding | 쓰기 성능 ↑ | 데이터 분산 | 여러 DB |
| Partitioning | 읽기 성능 ↑ | 테이블 분할 | 단일 DB 내 |

---

### 7. Isolation (격리성) 구현 방식

#### 개념
- 동시 트랜잭션이 서로 독립적으로 동작하도록 보장

#### 구현 방식 (2가지)
_상세 설명은 녹음에서 미완성 부분_

---

## 핵심 정리

### ACID 요점
- **A**: 전체 성공 또는 전체 실패
- **C**: 데이터 정확성 보장
- **I**: 동시성 제어
- **D**: 영구 저장

### RDBMS 선택 기준
✅ 데이터 정확성 중요
✅ ACID 특성 필요
✅ 정형 데이터

### NoSQL 선택 기준
✅ 대용량 처리
✅ 빠른 읽기/쓰기
✅ 스키마 자유도 필요

### 확장 전략 순서
1. **Replication** (읽기 복제) - 가장 먼저
2. **Cache** (캐싱) - 동시에 고려
3. **Partitioning** (파티셔닝) - 읽기 최적화
4. **Sharding** (샤딩) - 마지막 수단

---

## 학습 포인트

### 이해해야 할 것
- 각 기술이 **왜** 필요한지
- 각 기술의 **목표**는 무엇인지
- **트레이드오프**는 무엇인지

### 주의사항
- 모든 상황에 같은 방식 적용 불가
- 테이블 구조와 데이터 특성에 따라 다름
- 과도한 복잡성 추가 지양

